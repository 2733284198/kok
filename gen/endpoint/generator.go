package endpoint

import (
	"fmt"
	"strings"

	"github.com/RussellLuo/kok/gen/util/generator"
	"github.com/RussellLuo/kok/gen/util/misc"
	"github.com/RussellLuo/kok/gen/util/openapi"
	"github.com/RussellLuo/kok/gen/util/reflector"
)

var (
	template = `// Code generated by kok; DO NOT EDIT.
// github.com/RussellLuo/kok

package {{.Result.PkgName}}

import (
	"github.com/go-kit/kit/endpoint"
	{{- range .Result.Imports}}
	"{{.}}"
	{{- end }}
)

{{- $srcPkgPrefix := .Result.SrcPkgPrefix}}
{{- $interfaceName := .Result.Interface.Name}}

{{- range .DocMethods}}

{{- $params := nonCtxParams .Params}}
{{- $hasCtxParam := hasCtxParam .Params}}

{{- if $params}}
type {{.Name}}Request struct {
	{{- range $params}}
	{{title .Name}} {{.Type}} {{addTag .Name .Type}}
	{{- end}}
}
{{- end}}

{{if .Returns -}}
type {{.Name}}Response struct {
	{{- range .Returns}}
	{{title .Name}} {{.Type}} {{addTag .Name .Type}}
	{{- end}}
}
{{- end}}

{{- $errParamName := getErrParamName .Returns}}
{{- if $errParamName}}
// Failed implements endpoint.Failer.
func (r {{addAsterisks .Name}}Response) Failed() error { return r.{{title $errParamName}} }
{{- end}}

// MakeEndpointOf{{.Name}} creates the endpoint for s.{{.Name}}.
func MakeEndpointOf{{.Name}}(s {{$srcPkgPrefix}}{{$interfaceName}}) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (interface{}, error) {
		{{- if $params}}
		req := request.({{addAsterisks .Name}}Request)
		{{- end}}

		{{- if .Returns}}
		{{joinName .Returns ", "}} := s.{{.Name}}(
			{{- if $hasCtxParam}}
			ctx,
			{{- end}}
			{{- range $params}}
			req.{{title .Name}} {{- if .Variadic}}...{{end}},
			{{- end}}
		)
		return {{addAmpersand .Name}}Response{
			{{- range .Returns}}
			{{title .Name}}: {{.Name}},
			{{- end}}
		}, nil
		{{- else}}
		s.{{.Name}}(
			{{- if $hasCtxParam}}
			ctx,
			{{- end}}
			{{- range $params}}
			req.{{title .Name}} {{- if .Variadic}}...{{end}},
			{{- end}}
		)
		return nil, nil
		{{- end}} {{/* End of if .Returns */}}
	}
}

{{- end}} {{/* End of range .DocMethods */}}
`
)

type Options struct {
	SchemaPtr         bool
	SchemaTag         string
	TagKeyToSnakeCase bool
	Formatted         bool
}

type Generator struct {
	opts *Options
}

func New(opts *Options) *Generator {
	return &Generator{opts: opts}
}

func (g *Generator) Generate(result *reflector.Result, spec *openapi.Specification) ([]byte, error) {
	operationMap := make(map[string]*openapi.Operation)
	for _, op := range spec.Operations {
		operationMap[op.Name] = op
	}

	var docMethods []*reflector.Method
	for _, m := range result.Interface.Methods {
		if _, ok := operationMap[m.Name]; ok {
			docMethods = append(docMethods, m)
		}
	}

	data := struct {
		Result     *reflector.Result
		DocMethods []*reflector.Method
	}{
		Result:     result,
		DocMethods: docMethods,
	}

	return generator.Generate(template, data, generator.Options{
		Funcs: map[string]interface{}{
			"title": strings.Title,
			"nonCtxParams": func(params []*reflector.Param) (out []*reflector.Param) {
				for _, p := range params {
					if p.Type != "context.Context" {
						out = append(out, p)
					}
				}
				return
			},
			"hasCtxParam": func(params []*reflector.Param) bool {
				for _, p := range params {
					if p.Type == "context.Context" {
						return true
					}
				}
				return false
			},
			"getErrParamName": func(params []*reflector.Param) string {
				for _, p := range params {
					if p.Type == "error" {
						return p.Name
					}
				}
				return ""
			},
			"joinName": func(returns []*reflector.Param, sep string) string {
				var names []string
				for _, r := range returns {
					names = append(names, r.Name)
				}
				return strings.Join(names, sep)
			},
			"addAsterisks": func(name string) string {
				if g.opts.SchemaPtr {
					return "*" + name
				}
				return name
			},
			"addAmpersand": func(name string) string {
				if g.opts.SchemaPtr {
					return "&" + name
				}
				return name
			},
			"addTag": func(name, typ string) string {
				if g.opts.SchemaTag == "" {
					return ""
				}

				if typ == "error" {
					name = "-"
				} else if g.opts.TagKeyToSnakeCase {
					name = misc.ToSnakeCase(name)
				}

				return fmt.Sprintf("`%s:\"%s\"`", g.opts.SchemaTag, name)
			},
		},
		Formatted: g.opts.Formatted,
	})
}
