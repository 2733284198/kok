// Code generated by kok; DO NOT EDIT.
// github.com/RussellLuo/kok

package profilesvc

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type ServiceClient struct {
	httpClient *http.Client
	scheme     string
	host       string
	pathPrefix string
}

func New(httpClient *http.Client, baseURL string) (*ServiceClient, error) {
	u, err := url.Parse(baseURL)
	if err != nil {
		return nil, err
	}
	return &ServiceClient{
		httpClient: httpClient,
		scheme:     u.Scheme,
		host:       u.Host,
		pathPrefix: strings.TrimSuffix(u.Path, "/"),
	}, nil
}

func (c *ServiceClient) DeleteAddress(ctx context.Context, profileID string, addressID string) (err error) {
	path := fmt.Sprintf("/profiles/%s/addresses/%s", profileID, addressID)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	if resp.StatusCode >= http.StatusOK && resp.StatusCode <= http.StatusNoContent {
		return nil
	} else {
		err := errors.New(string(respBodyBytes))
		return err
	}
}

func (c *ServiceClient) DeleteProfile(ctx context.Context, id string) (err error) {
	path := fmt.Sprintf("/profiles/%s", id)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	if resp.StatusCode >= http.StatusOK && resp.StatusCode <= http.StatusNoContent {
		return nil
	} else {
		err := errors.New(string(respBodyBytes))
		return err
	}
}

func (c *ServiceClient) GetAddress(ctx context.Context, profileID string, addressID string) (address Address, err error) {
	path := fmt.Sprintf("/profiles/%s/addresses/%s", profileID, addressID)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return Address{}, err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return Address{}, err
	}
	defer resp.Body.Close()

	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return Address{}, err
	}

	if resp.StatusCode >= http.StatusOK && resp.StatusCode <= http.StatusNoContent {
		var respBody struct {
			Address Address `json:"address"`
		}
		err := json.Unmarshal(respBodyBytes, &respBody)
		if err != nil {
			return Address{}, err
		}
		return respBody.Address, nil
	} else {
		err := errors.New(string(respBodyBytes))
		return Address{}, err
	}
}

func (c *ServiceClient) GetAddresses(ctx context.Context, id string) (addresses []Address, err error) {
	path := fmt.Sprintf("/profiles/%s/addresses", id)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode >= http.StatusOK && resp.StatusCode <= http.StatusNoContent {
		var respBody struct {
			Addresses []Address `json:"addresses"`
		}
		err := json.Unmarshal(respBodyBytes, &respBody)
		if err != nil {
			return nil, err
		}
		return respBody.Addresses, nil
	} else {
		err := errors.New(string(respBodyBytes))
		return nil, err
	}
}

func (c *ServiceClient) GetProfile(ctx context.Context, id string) (profile Profile, err error) {
	path := fmt.Sprintf("/profiles/%s", id)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return Profile{}, err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return Profile{}, err
	}
	defer resp.Body.Close()

	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return Profile{}, err
	}

	if resp.StatusCode >= http.StatusOK && resp.StatusCode <= http.StatusNoContent {
		var respBody struct {
			Profile Profile `json:"profile"`
		}
		err := json.Unmarshal(respBodyBytes, &respBody)
		if err != nil {
			return Profile{}, err
		}
		return respBody.Profile, nil
	} else {
		err := errors.New(string(respBodyBytes))
		return Profile{}, err
	}
}

func (c *ServiceClient) PatchProfile(ctx context.Context, id string, profile Profile) (err error) {
	path := fmt.Sprintf("/profiles/%s", id)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	reqBody := struct {
		Profile Profile `json:"profile"`
	}{
		Profile: profile,
	}
	reqBodyBytes, err := json.Marshal(&reqBody)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("PATCH", u.String(), bytes.NewBuffer(reqBodyBytes))
	if err != nil {
		return err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	if resp.StatusCode >= http.StatusOK && resp.StatusCode <= http.StatusNoContent {
		return nil
	} else {
		err := errors.New(string(respBodyBytes))
		return err
	}
}

func (c *ServiceClient) PostAddress(ctx context.Context, profileID string, address Address) (err error) {
	path := fmt.Sprintf("/profiles/%s/addresses", profileID)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	reqBody := struct {
		Address Address `json:"address"`
	}{
		Address: address,
	}
	reqBodyBytes, err := json.Marshal(&reqBody)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", u.String(), bytes.NewBuffer(reqBodyBytes))
	if err != nil {
		return err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	if resp.StatusCode >= http.StatusOK && resp.StatusCode <= http.StatusNoContent {
		return nil
	} else {
		err := errors.New(string(respBodyBytes))
		return err
	}
}

func (c *ServiceClient) PostProfile(ctx context.Context, profile Profile) (err error) {
	path := "/profiles"
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	reqBody := struct {
		Profile Profile `json:"profile"`
	}{
		Profile: profile,
	}
	reqBodyBytes, err := json.Marshal(&reqBody)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", u.String(), bytes.NewBuffer(reqBodyBytes))
	if err != nil {
		return err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	if resp.StatusCode >= http.StatusOK && resp.StatusCode <= http.StatusNoContent {
		return nil
	} else {
		err := errors.New(string(respBodyBytes))
		return err
	}
}

func (c *ServiceClient) PutProfile(ctx context.Context, id string, profile Profile) (err error) {
	path := fmt.Sprintf("/profiles/%s", id)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	reqBody := struct {
		Profile Profile `json:"profile"`
	}{
		Profile: profile,
	}
	reqBodyBytes, err := json.Marshal(&reqBody)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("PUT", u.String(), bytes.NewBuffer(reqBodyBytes))
	if err != nil {
		return err
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	if resp.StatusCode >= http.StatusOK && resp.StatusCode <= http.StatusNoContent {
		return nil
	} else {
		err := errors.New(string(respBodyBytes))
		return err
	}
}
